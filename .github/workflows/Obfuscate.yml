name: Build Obfuscate BPB Panel

permissions:
  contents: write

on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 */3 * * *'

jobs:
  build:
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'latest'

      - name: Install dependencies
        run: |
          npm install
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Get local release version
        id: get_local_version
        run: echo "RELEASE_VERSION=$(jq -r .version package.json)" >> $GITHUB_ENV

      - name: Fetch latest upstream release and worker.js
        id: fetch_upstream
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          UPSTREAM_OWNER: lizhi123le                   # <-- 替换为实际 upstream owner/org
          UPSTREAM_REPO: BPB-Worker-Panel              # <-- 替换为实际 upstream repo
        run: |
          set -euo pipefail

          # 查询 upstream 的 latest release 信息并下载 worker.js（如果存在）
          echo "Querying latest release for $UPSTREAM_OWNER/$UPSTREAM_REPO"
          RELEASE_INFO=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/$UPSTREAM_OWNER/$UPSTREAM_REPO/releases/latest")

          RELEASE_TAG=$(echo "$RELEASE_INFO" | jq -r '.tag_name // empty')
          echo "upstream_release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

          DOWNLOAD_URL=$(echo "$RELEASE_INFO" | jq -r '.assets[] | select(.name=="worker.js") | .browser_download_url' || true)
          if [ -n "$DOWNLOAD_URL" ]; then
            echo "Found worker.js at $DOWNLOAD_URL, downloading..."
            wget -q -O origin.js "$DOWNLOAD_URL"
            echo "Downloaded origin.js size:" && ls -l origin.js || true
          else
            echo "No worker.js asset found in latest upstream release."
          fi

          # 拉取 upstream 仓库 dev 分支的 package.json（用于同步版本）
          echo "Downloading upstream package.json (dev branch)"
          wget -q -O /tmp/upstream_package.json "https://raw.githubusercontent.com/$UPSTREAM_OWNER/$UPSTREAM_REPO/refs/heads/dev/package.json" || true
          if [ -f /tmp/upstream_package.json ]; then
            echo "upstream_package_json=true" >> $GITHUB_OUTPUT
            head -n 5 /tmp/upstream_package.json || true
          else
            echo "upstream_package_json=false" >> $GITHUB_OUTPUT
          fi

          # 下载本仓库 RELEASE.md（可选）
          if wget -q -O RELEASE.md "https://raw.githubusercontent.com/$UPSTREAM_OWNER/$UPSTREAM_REPO/refs/heads/dev/RELEASE.md" || true; then
            echo "RELEASE_md=true" >> $GITHUB_OUTPUT
          else
            echo "RELEASE_md=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract upstream version
        id: extract_upstream_version
        run: |
          set -euo pipefail
          if [ -f /tmp/upstream_package.json ]; then
            VERSION=$(jq -r '.version // empty' /tmp/upstream_package.json)
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          else
            echo "version=" >> $GITHUB_OUTPUT
          fi

      - name: Sync package.json version (if found)
        run: |
          set -euo pipefail
          UPVER="${{ steps.extract_upstream_version.outputs.version }}"
          if [ -z "$UPVER" ]; then
            echo "No upstream version found; skipping package.json sync."
            exit 0
          fi

          # 备份并更新 package.json 的 version 字段
          cp package.json package.json.bak
          jq --arg v "$UPVER" '.version = $v' package.json > package.json.tmp && mv package.json.tmp package.json

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add package.json
          git commit -m "chore: sync package.json version from upstream ($UPVER)" || echo "No version change to commit"
          git push || echo "Push failed (maybe no credential); continuing"

      - name: Commit artifacts back to repo
        if: always()
        env:
          GIT_AUTHOR_NAME: "github-actions[bot]"
          GIT_AUTHOR_EMAIL: "github-actions[bot]@users.noreply.github.com"
        run: |
          set -euo pipefail
          git status --porcelain --untracked-files=all || true

          # Stage artifacts (output dir and optional files)
          git add -A output || true
          [ -f origin.js ] && git add origin.js || true
          [ -f RELEASE.md ] && git add RELEASE.md || true

          echo "Staged changes:"
          git --no-pager diff --cached --name-status || true

          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git -c user.name="$GIT_AUTHOR_NAME" -c user.email="$GIT_AUTHOR_EMAIL" commit -m "chore(ci): add build artifacts from workflow"
            git push origin HEAD:main || echo "Push failed (check permissions)"
          fi

      - name: Build
        run: npm run build

      - name: Prepare release notes and collect artifacts
        id: prepare_artifacts
        run: |
          set -euo pipefail

          # Read RELEASE.md into output variable (URL-encode newlines)
          if [ -f RELEASE.md ]; then
            # encode percent and newlines so it is safe to pass as a single-line output
            body=$(sed -e ':a' -e 'N' -e '$!ba' -e 's/%/%25/g' -e 's/\n/%0A/g' RELEASE.md)
            echo "RELEASE_BODY=$body" >> $GITHUB_OUTPUT
          else
            echo "RELEASE_BODY=" >> $GITHUB_OUTPUT
          fi

          # Ensure dist exists
          if [ ! -d dist ]; then
            echo "Error: dist directory not found. Build may have failed."
            ls -la
            exit 1
          fi

          # Prepare output dir and copy artifacts
          mkdir -p output
          # Use a safe copy pattern that won't fail the workflow command processing
          # and avoid creating outputs with names that include newlines or other invalid chars.
          shopt -s nullglob
          copied_files=()
          for f in dist/*; do
            cp -a "$f" output/ || { echo "Failed to copy $f"; ls -la dist; exit 1; }
            copied_files+=("$(basename "$f")")
          done
          shopt -u nullglob

          # copy optional files if present
          [ -f origin.js ] && cp origin.js output/ || true
          [ -f RELEASE.md ] && cp RELEASE.md output/ || true
          # If dist/_worker.js exists, copy it into repository root as _worker.js (but avoid adding invalid output lines)
          if [ -f dist/_worker.js ]; then
            cp dist/_worker.js _worker.js || true
          fi

          # Build a safe, newline-separated list for output (no trailing newlines that could confuse workflow commands)
          if [ -d output ]; then
            files_list=$(ls -1 output | sed -e ':a' -e 'N' -e '$!ba' -e 's/%/%25/g' -e 's/\n/%0A/g')
            echo "output_list=$files_list" >> $GITHUB_OUTPUT
          else
            echo "output_list=" >> $GITHUB_OUTPUT
          fi
		  
      - name: Commit build artifacts back to repo
        if: always()
        env:
          GIT_AUTHOR_NAME: "github-actions[bot]"
          GIT_AUTHOR_EMAIL: "github-actions[bot]@users.noreply.github.com"
        run: |
          set -euo pipefail
          git status --porcelain --untracked-files=all || true

          # Stage artifacts (output dir and optional files)
          git add -A output || true
          [ -f _worker.js ] && git add _worker.js || true

          echo "Staged changes:"
          git --no-pager diff --cached --name-status || true

          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git -c user.name="$GIT_AUTHOR_NAME" -c user.email="$GIT_AUTHOR_EMAIL" commit -m "chore(ci): add build artifacts from workflow"
            git push origin HEAD:main || echo "Push failed (check permissions)"
          fi

      - name: Upload Release Assets
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: output/*            # 上传 output 下的产物（以及 dist 下复制过来的文件）
          tag: v${{ env.RELEASE_VERSION }}
          release_name: Release v${{ env.RELEASE_VERSION }}
          overwrite: true
          file_glob: true
          prerelease: false
          body: ${{ steps.prepare_artifacts.outputs.RELEASE_BODY }}
